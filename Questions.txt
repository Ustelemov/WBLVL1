Вопрос: Какой самый эффективный способ конкатенации строк?
Ответ: Использование strings.Builder

Вопрос: Что такое интерфейсы, как они применяются в Go?
Ответ: Интерфейс - именованная коллекция сигнатур методов (описание методов без реализации).
Используются для описания ожидаемого поведения типа.
Для реализации полиморфизма.
Также интерфейс - это тип, пустой интерфейс позволяет хранить значения любого типа, так как
любой тип реализует пустой интерфейс, в нем хранитcя: ссылка на лежащий в нем тип и ссылка на данные.

Вопрос: Чем отличаются RWMutex от Mutex?
Ответ: Если в Mutex Lock() блокирует все дальнейшие вызовы Lock() до вызова Unlock(),
то RWMutex используется, когда возможно конкурентное чтение, но не возможна конкурентная
запись (например с map). Так RLock() будет блокировать дальнешие Lock() (до RUnlock()), но не будет блокировать
другие RLock().

Вопрос: Чем отличаются буферизированные и не буферизированные каналы?
Ответ: отправитель в небуферизированный канал блокируется, до того как значение не будет
прочитано из канала. Отправитель в буферизированный канал блокируется только до момента
пока значение не будет скопировано в буфер и блокируется до чтения только когда буфер - полон.

Вопрос: Какой размер у структуры struct{}{}
0 байт

Вопрос: Есть ли в Go перегрузка методов или операторов?
Ответ: Нет. Но есть возможность реализовать похожее на перегрузку поведение через интерфейс.

Вопрос: В какой последовательности будут выведены элементы map[int]int
Порядок обхода не определен и может отличаться от итерации к итерации (от обхода к обходу)

Вопрос: В чем разница make и new?
Ответ: New - выделяет память, но не инициализирует объект. make - выделяет память и инициализирует объект.

Вопрос: Сколько существует способов задать переменную типа slice или map?
Ответ:
var s []int
s := *new([]int)
s := make([]int, 0)
s := []int{1,2,3}
s := []int{}
s := append([]int{},1,2,3,4)
s1 := s 

Вопрос: Что выведется и почему?
func Update(p *int) {
	b := 2
	p = &b
}

func main() {
	var (
		a = 1
		p = &a
	)
	fmt.Println(*p)
	Update(p)
	fmt.Println(*p)
}

Ответ: выведется 1 1, так как в Update мы передаем p по значению, создавая копию.
В итоге просто изменяем значение адреса в памяти для этой копии, чтобы изменить само значение
требовалось бы разыменовать *p и присвоить 2, то есть непосредственно записать в ячейку.

Вопрос: Что выведется и почему?
func main() {
	wg := sync.WaitGroup{}
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(wg sync.WaitGroup, i int) {
			fmt.Println(i)
			wg.Done()
		}(wg, i)
	}
	wg.Wait()
	fmt.Println("exit")
}

Ответ: напечатаются числа 0-4 в некотором неопределенном порядке и сообщение о deadlock.
Так как мы никогда не дождемся wg.Wait() из-за того, что wg.Done() вызывается у копии
WaitGroup, передаваемой в анонимную функцию. Чтобы работало корректно в сигнатуре
анонимной функции sync.WaitGroup -> *sync.WaitGroup и передавать как &wg.

Вопрос: Что выведется и почему?
func main() {
	n := 0
	if true {
		n := 1
		n++
	}
	fmt.Println(n)
}

Ответ: 0. Так как мы объявляем новую переменную n в локальной зоне if'а и меняем её.
Если хотим получить 2: n:=1 поменять на n=1

Вопрос: Что выведется и почему?
func someAction(v []int8, b int8) {
	v[0] = 100
	v = append(v, b)
}

func main() {
	var a = []int8{1, 2, 3, 4, 5}
	someAction(a, 6)
	fmt.Println(a)
}
Ответ: 100 2 3 4 5. Header слайса передается по значению и его модификация не изменяет
передаваемый header. Значение же массива изменяется. Если бы хотели 100 2 3 4 5 6, то 
header нужно было бы передать по ссылке, изменив сигнатуру метода someAction.

func main() {
	slice := []string{"a", "a"}

	func(slice []string) {
		slice = append(slice, "a")
		slice[0] = "b"
		slice[1] = "b"
		fmt.Println(slice)
	}(slice)
	fmt.Println(slice)
}

Ответ: bba, aa. Append'ом мы создаем новый слайс и теперь уже модификации не затрагивают
слайс переданный как параметр. Он остается неизменным - "а" "а".